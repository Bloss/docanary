const path = require('path');
const Config = require('webpack-chain');
const ExtractCssPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const MarkdownLoader = require.resolve('../markdown-loader');

function applyBabel(rule, { isServer }) {
	rule
		.use('babel')
		.loader('babel-loader')
		.options({
			babelrc: false,
			// don't pick local babel.config.js
			configFile: false,
			presets: ['@babel/preset-env', '@babel/preset-react'].map(
				require.resolve,
			),
			plugins: [
				isServer
					? 'babel-plugin-dynamic-import-node'
					: '@babel/plugin-syntax-dynamic-import',
				'react-loadable/babel',
			].map(require.resolve),
		});
}

function applyCss(baseRule, loader, { options, isServer, isProd }) {
	const modulesRule = baseRule.oneOf('modules').resourceQuery(/module/);
	const normalRule = baseRule.oneOf('normal');

	applyLoaders(modulesRule, true);
	applyLoaders(normalRule, false);

	function applyLoaders(rule, isModule) {
		if (!isServer) {
			if (isProd) {
				rule.use('extract-css-loader').loader(ExtractCssPlugin.loader);
			} else {
				rule.use('style-loader').loader('style-loader');
			}
		}

		rule
			.use('css-loader')
			.loader(isServer ? 'css-loader/locals' : 'css-loader')
			.options({
				modules: isModule,
				localIdentName: `[local]_[hash:base64:8]`,
				importLoaders: 1,
				sourceMap: !isProd,
			});

		rule
			.use('postcss-loader')
			.loader('postcss-loader')
			.options({
				plugins: [require('autoprefixer')],
				sourceMap: !isProd,
			});

		if (loader) {
			rule
				.use(loader)
				.loader(loader)
				.options(options);
		}
	}
}

function getModulePaths(siteDir) {
	return [path.resolve(siteDir, 'node_modules')].concat(module.paths);
}

module.exports = function createBaseConfig(options, isServer) {
	const isProd = process.env.NODE_ENV === 'production';

	const { outDir, baseUrl, siteDir, siteConfig, injectComponents } = options;

	const config = new Config();

	config
		.mode(isProd ? 'production' : 'development')
		.output.path(outDir)
		.filename(isProd ? '[name].[chunkhash].js' : '[name].js')
		.publicPath(isProd ? baseUrl : '/');

	if (!isProd) {
		config.devtool('cheap-module-eval-source-map');
	}
	const modulePaths = getModulePaths(siteDir);

	config.resolveLoader.set('symlinks', true).modules.merge(modulePaths);

	config.resolve
		.set('symlinks', true)
		.alias.set('@utils', path.resolve(__dirname, '../utils'))
		.set('@core', path.resolve(__dirname, '../core'))
		.set('@theme', path.resolve(__dirname, '../theme'))
		.set('@generated', path.resolve(__dirname, '../core/generated'))
		.set('@docanary', path.resolve(__dirname, '../docanary'))
		.set('@site', siteDir)
		.set('@build', outDir)
		.end()
		.modules.merge(modulePaths);

	const jsRule = config.module
		.rule('js')
		.test(/\.jsx?$/)
		.exclude.add(filepath => {
			// don't exclude our own lib directory
			if (filepath.startsWith(path.join(__dirname, '..'))) {
				return false;
			}

			return /node_module/.test(filepath);
		})
		.end();

	applyBabel(jsRule, { isServer });

	const mdRule = config.module.rule('markdown').test(/\.md$/);

	// For jsx generated by markdown
	applyBabel(mdRule, { isServer });

	mdRule
		.use('markdown-loader')
		.loader(MarkdownLoader)
		.options({ markdown: siteConfig.markdown, injectComponents });

	function createCssRule(lang, re) {
		const rule = config.module.rule(lang).test(re);
		return rule;
	}

	const cssRule = createCssRule('css', /\.css$/);
	applyCss(cssRule, null, { isServer, isProd });

	const postcssRule = createCssRule('postcss', /\.p(ost)?css$/);
	applyCss(postcssRule, null, { isServer, isProd });

	const scssRule = createCssRule('scss', /\.scss$/);
	applyCss(scssRule, 'sass-loader', { isServer, isProd });

	const sassRule = createCssRule('sass', /\.sass$/);
	applyCss(sassRule, 'sass-loader', {
		isServer,
		isProd,
		options: {
			indentedSyntax: true,
		},
	});

	const lessRule = createCssRule('less', /\.less$/);
	applyCss(lessRule, 'less-loader', { isServer, isProd });

	const stylusRule = createCssRule('stylus', /.styl(us)?$/);
	applyCss(stylusRule, 'stylus-loader', {
		isServer,
		isProd,
		options: {
			preferPathResolver: 'webpack',
		},
	});

	config.module
		.rule('images')
		.test(/\.(png|jpe?g|gif)(\?.*)?$/)
		.use('url-loader')
		.loader('url-loader')
		.options({
			limit: 10000,
			name: `assets/img/[name].[hash:8].[ext]`,
		});

	config.module
		.rule('svg')
		.test(/\.(svg)(\?.*)?$/)
		.use('file-loader')
		.loader('file-loader')
		.options({
			name: `assets/img/[name].[hash:8].[ext]`,
		});

	config.module
		.rule('media')
		.test(/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/)
		.use('url-loader')
		.loader('url-loader')
		.options({
			limit: 10000,
			name: `assets/media/[name].[hash:8].[ext]`,
		});

	config.plugin('extract-css').use(ExtractCssPlugin, [
		{
			filename: isProd ? '[name].[chunkhash].css' : '[name.css]',
			chunkFilename: isProd ? '[id].[chunkhash].css' : '[id].css',
		},
	]);

	if (isProd) {
		config.optimization.minimizer('terser').use(TerserPlugin, [
			{
				cache: true,
				parallel: true,
				sourceMap: true,
				terserOptions: {
					ecma: 6,
					mangle: true,
					output: { comments: false },
				},
			},
		]);
	}

	return config;
};
